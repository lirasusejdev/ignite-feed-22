"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sprintf;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _setPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/setPrototypeOf"));

function _wrapRegExp() { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); _groups.set(_this, groups || _groups.get(re)); return (0, _setPrototypeOf2.default)(_this, BabelRegExp.prototype); } (0, _inherits2.default)(BabelRegExp, RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; if (_typeof3(args[args.length - 1]) !== "object") { args = [].slice.call(args); args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }

function maybeReplace(format, pattern, replacementFn) {
  return format.replace(pattern, function (match, lookbehind) {
    // https://caniuse.com/#search=lookbehind
    if (lookbehind === '%') {
      return match;
    }

    var replacement = replacementFn();

    if (replacement === undefined) {
      return match;
    }

    return replacement;
  });
}
/**
 * Simple function for formatting strings. Replaces placeholders with values
 * passed as extra arguments.
 *
 * See: https://nodejs.org/api/util.html#util_util_format_format_args
 */


function sprintf(format) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var argsLength = args.length;

  if (argsLength === 0) {
    return format;
  }

  var index = 0;
  var withString = maybeReplace(format, /*#__PURE__*/_wrapRegExp(/(%)?%s/g, {
    lookbehind: 1
  }), function () {
    return index >= argsLength ? undefined : String(args[index++]);
  });
  var withJSON = maybeReplace(withString, /*#__PURE__*/_wrapRegExp(/(%)?%j/g, {
    lookbehind: 1
  }), function () {
    return index >= argsLength ? undefined : String(JSON.stringify(args[index++], getCircularReplacer()));
  });

  for (index; index < argsLength; index++) {
    withJSON += " ".concat(String(args[index]));
  }

  return withJSON.replace(/%%/g, '%');
}

function getCircularReplacer() {
  var seen = new WeakSet();
  return function (key, value) {
    if ((0, _typeof2.default)(value) === 'object' && value !== null) {
      if (seen.has(value)) {
        return '[Circular]';
      }

      seen.add(value);
    }

    return value;
  };
}