"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var React = _interopRequireWildcard(require("react"));

const useBoundingRect = initialValue => {
  const [state, setState] = React.useState(() => (0, _objectSpread2.default)({
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, initialValue));
  const ref = React.useRef(null);
  React.useEffect(() => {
    const calculate = () => {
      if (ref && ref.current) {
        const dimensions = ref.current.getBoundingClientRect();
        /* $FlowFixMe
        Somehow the Flow is confused and returns type ClientRect instead of DOMRect and therefore it expects that it's a function.
        */

        setState(dimensions);
      }
    };

    calculate();
    window.addEventListener("resize", calculate);
    return () => {
      window.removeEventListener("resize", calculate);
    };
  }, []); // $FlowFixMe

  return [state, ref];
};

var _default = useBoundingRect;
exports.default = _default;