"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireWildcard(require("styled-components"));

var _scroll = require("../utils/scroll");

var _defaultTheme = _interopRequireDefault(require("../defaultTheme"));

const StyledSticky = _styledComponents.default.div.withConfig({
  displayName: "Sticky__StyledSticky",
  componentId: "sc-s1pqaa-0"
})([""]);

const StyledStickyContent = _styledComponents.default.div.withConfig({
  displayName: "Sticky__StyledStickyContent",
  componentId: "sc-s1pqaa-1"
})(["position:", ";", ";box-shadow:0 2px 20px 6px rgba(23,27,30,0.15);border-radius:", ";"], ({
  sticky
}) => sticky ? `fixed` : `relative`, ({
  size,
  initialWidth
}) => (0, _styledComponents.css)(["top:", ";width:", ";"], size.height && `${size.height}px`, size.width && !initialWidth && `${size.width}px` || `100%`), ({
  theme
}) => theme.orbit.borderRadiusNormal); // $FlowFixMe: https://github.com/flow-typed/flow-typed/issues/3653#issuecomment-568539198


StyledStickyContent.defaultProps = {
  theme: _defaultTheme.default
};

class Sticky extends React.Component {
  constructor(...args) {
    super(...args);
    this.state = {
      sticky: false,
      height: 0,
      initialWidth: true,
      initialTop: 0,
      width: 0
    };
    this.content = /*#__PURE__*/React.createRef();
    this.sticky = /*#__PURE__*/React.createRef();

    this.handleTop = () => {
      if (this.sticky.current) {
        const values = this.sticky.current.getBoundingClientRect();
        this.setState({
          initialTop: values.top
        });
      }
    };

    this.stickyState = (sticky, height, width) => {
      this.setState({
        sticky,
        height,
        width
      });
    };

    this.handleScroll = () => {
      const element = this.content.current;
      const sticky = this.sticky.current;
      const elementHeight = element.offsetHeight; // $FlowFixMe

      const parent = sticky.parentNode.getBoundingClientRect();
      const scrollingElement = (0, _scroll.getScrollingElement)().getBoundingClientRect();
      const {
        offset = 0
      } = this.props;
      const {
        initialTop
      } = this.state;
      this.setState({
        initialWidth: false
      }); // if (sets fixed position if window with offset reaches elements and current position is not on the bottom of parent element)

      if (Math.abs(scrollingElement.top) + offset >= initialTop && parent.bottom - elementHeight - offset >= 0) {
        this.stickyState(true, offset, parent.width); // turns off fixed if it's on the bottom of parent's element
      } else if (parent.bottom - elementHeight - offset <= 0) {
        this.stickyState(false, parent.height - elementHeight, parent.width);
      } else {
        // just off fixed
        this.stickyState(false, 0, parent.width);
      }
    };
  }

  componentDidMount() {
    this.handleTop();
    (0, _scroll.addScrollHandler)(this.handleScroll);
    window.addEventListener("resize", this.handleTop);
    window.addEventListener("resize", this.handleScroll);
  }

  componentWillUnmount() {
    window.removeEventListener("resize", this.handleTop);
    window.removeEventListener("resize", this.handleScroll);
    (0, _scroll.removeScrollHandler)(this.handleScroll);
  }

  render() {
    const {
      children,
      dataTest,
      id
    } = this.props;
    const {
      sticky,
      height,
      width,
      initialWidth
    } = this.state;
    return /*#__PURE__*/React.createElement(StyledSticky, {
      ref: this.sticky,
      "data-test": dataTest,
      id: id
    }, /*#__PURE__*/React.createElement(StyledStickyContent, {
      sticky: sticky,
      size: {
        height,
        width
      },
      initialWidth: initialWidth,
      ref: this.content
    }, children));
  }

}

var _default = Sticky;
exports.default = _default;